// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: predictor.proto
#ifndef GRPC_predictor_2eproto__INCLUDED
#define GRPC_predictor_2eproto__INCLUDED

#include "predictor.pb.h"

#include <grpc++/impl/codegen/async_stream.h>
#include <grpc++/impl/codegen/async_unary_call.h>
#include <grpc++/impl/codegen/method_handler_impl.h>
#include <grpc++/impl/codegen/proto_utils.h>
#include <grpc++/impl/codegen/rpc_method.h>
#include <grpc++/impl/codegen/service_type.h>
#include <grpc++/impl/codegen/status.h>
#include <grpc++/impl/codegen/stub_options.h>
#include <grpc++/impl/codegen/sync_stream.h>

namespace grpc {
class CompletionQueue;
class Channel;
class RpcService;
class ServerCompletionQueue;
class ServerContext;
}  // namespace grpc

namespace carml {
namespace org {
namespace predictor {

class Predict final {
 public:
  static constexpr char const* service_full_name() {
    return "carml.org.predictor.Predict";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Opens a predictor and returns an id where the predictor
    // is accessible. The id can be used to perform inference
    // requests.
    virtual ::grpc::Status Open(::grpc::ClientContext* context, const ::carml::org::predictor::PredictorOpenRequest& request, ::carml::org::predictor::Predictor* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::carml::org::predictor::Predictor>> AsyncOpen(::grpc::ClientContext* context, const ::carml::org::predictor::PredictorOpenRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::carml::org::predictor::Predictor>>(AsyncOpenRaw(context, request, cq));
    }
    // rpc Information(Predictor) returns (PredictorInformation) {
    //   option (google.api.http) = {
    //     post : "/v1/predict/information",
    //     body : "*"
    //   };
    // }
    //
    // Close a predictor clear it's memory.
    virtual ::grpc::Status Close(::grpc::ClientContext* context, const ::carml::org::predictor::Predictor& request, ::carml::org::predictor::PredictorCloseResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::carml::org::predictor::PredictorCloseResponse>> AsyncClose(::grpc::ClientContext* context, const ::carml::org::predictor::Predictor& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::carml::org::predictor::PredictorCloseResponse>>(AsyncCloseRaw(context, request, cq));
    }
    // Image method receives a stream of urls and runs
    // the predictor on all the urls. The
    //
    // The result is a prediction feature stream for each url.
    virtual ::grpc::Status URLs(::grpc::ClientContext* context, const ::carml::org::predictor::URLsRequest& request, ::carml::org::predictor::FeaturesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::carml::org::predictor::FeaturesResponse>> AsyncURLs(::grpc::ClientContext* context, const ::carml::org::predictor::URLsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::carml::org::predictor::FeaturesResponse>>(AsyncURLsRaw(context, request, cq));
    }
    // Image method receives a stream of urls and runs
    // the predictor on all the urls. The
    //
    // The result is a prediction feature stream for each url.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::carml::org::predictor::FeatureResponse>> URLsStream(::grpc::ClientContext* context, const ::carml::org::predictor::URLsRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::carml::org::predictor::FeatureResponse>>(URLsStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::carml::org::predictor::FeatureResponse>> AsyncURLsStream(::grpc::ClientContext* context, const ::carml::org::predictor::URLsRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::carml::org::predictor::FeatureResponse>>(AsyncURLsStreamRaw(context, request, cq, tag));
    }
    // Image method receives a list base64 encoded images and runs
    // the predictor on all the images.
    //
    // The result is a prediction feature list for each image.
    virtual ::grpc::Status Images(::grpc::ClientContext* context, const ::carml::org::predictor::ImagesRequest& request, ::carml::org::predictor::FeaturesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::carml::org::predictor::FeaturesResponse>> AsyncImages(::grpc::ClientContext* context, const ::carml::org::predictor::ImagesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::carml::org::predictor::FeaturesResponse>>(AsyncImagesRaw(context, request, cq));
    }
    // Image method receives a list base64 encoded images and runs
    // the predictor on all the images.
    //
    // The result is a prediction feature stream for each image.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::carml::org::predictor::FeatureResponse>> ImagesStream(::grpc::ClientContext* context, const ::carml::org::predictor::ImagesRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::carml::org::predictor::FeatureResponse>>(ImagesStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::carml::org::predictor::FeatureResponse>> AsyncImagesStream(::grpc::ClientContext* context, const ::carml::org::predictor::ImagesRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::carml::org::predictor::FeatureResponse>>(AsyncImagesStreamRaw(context, request, cq, tag));
    }
    // Dataset method receives a single dataset and runs
    // the predictor on all elements of the dataset.
    //
    // The result is a prediction feature list.
    virtual ::grpc::Status Dataset(::grpc::ClientContext* context, const ::carml::org::predictor::DatasetRequest& request, ::carml::org::predictor::FeaturesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::carml::org::predictor::FeaturesResponse>> AsyncDataset(::grpc::ClientContext* context, const ::carml::org::predictor::DatasetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::carml::org::predictor::FeaturesResponse>>(AsyncDatasetRaw(context, request, cq));
    }
    // Dataset method receives a single dataset and runs
    // the predictor on all elements of the dataset.
    //
    // The result is a prediction feature stream.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::carml::org::predictor::FeatureResponse>> DatasetStream(::grpc::ClientContext* context, const ::carml::org::predictor::DatasetRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::carml::org::predictor::FeatureResponse>>(DatasetStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::carml::org::predictor::FeatureResponse>> AsyncDatasetStream(::grpc::ClientContext* context, const ::carml::org::predictor::DatasetRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::carml::org::predictor::FeatureResponse>>(AsyncDatasetStreamRaw(context, request, cq, tag));
    }
    // Clear method clears the internal cache of the predictors
    virtual ::grpc::Status Reset(::grpc::ClientContext* context, const ::carml::org::predictor::ResetRequest& request, ::carml::org::predictor::ResetResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::carml::org::predictor::ResetResponse>> AsyncReset(::grpc::ClientContext* context, const ::carml::org::predictor::ResetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::carml::org::predictor::ResetResponse>>(AsyncResetRaw(context, request, cq));
    }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::carml::org::predictor::Predictor>* AsyncOpenRaw(::grpc::ClientContext* context, const ::carml::org::predictor::PredictorOpenRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::carml::org::predictor::PredictorCloseResponse>* AsyncCloseRaw(::grpc::ClientContext* context, const ::carml::org::predictor::Predictor& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::carml::org::predictor::FeaturesResponse>* AsyncURLsRaw(::grpc::ClientContext* context, const ::carml::org::predictor::URLsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::carml::org::predictor::FeatureResponse>* URLsStreamRaw(::grpc::ClientContext* context, const ::carml::org::predictor::URLsRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::carml::org::predictor::FeatureResponse>* AsyncURLsStreamRaw(::grpc::ClientContext* context, const ::carml::org::predictor::URLsRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::carml::org::predictor::FeaturesResponse>* AsyncImagesRaw(::grpc::ClientContext* context, const ::carml::org::predictor::ImagesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::carml::org::predictor::FeatureResponse>* ImagesStreamRaw(::grpc::ClientContext* context, const ::carml::org::predictor::ImagesRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::carml::org::predictor::FeatureResponse>* AsyncImagesStreamRaw(::grpc::ClientContext* context, const ::carml::org::predictor::ImagesRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::carml::org::predictor::FeaturesResponse>* AsyncDatasetRaw(::grpc::ClientContext* context, const ::carml::org::predictor::DatasetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::carml::org::predictor::FeatureResponse>* DatasetStreamRaw(::grpc::ClientContext* context, const ::carml::org::predictor::DatasetRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::carml::org::predictor::FeatureResponse>* AsyncDatasetStreamRaw(::grpc::ClientContext* context, const ::carml::org::predictor::DatasetRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::carml::org::predictor::ResetResponse>* AsyncResetRaw(::grpc::ClientContext* context, const ::carml::org::predictor::ResetRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status Open(::grpc::ClientContext* context, const ::carml::org::predictor::PredictorOpenRequest& request, ::carml::org::predictor::Predictor* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::carml::org::predictor::Predictor>> AsyncOpen(::grpc::ClientContext* context, const ::carml::org::predictor::PredictorOpenRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::carml::org::predictor::Predictor>>(AsyncOpenRaw(context, request, cq));
    }
    ::grpc::Status Close(::grpc::ClientContext* context, const ::carml::org::predictor::Predictor& request, ::carml::org::predictor::PredictorCloseResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::carml::org::predictor::PredictorCloseResponse>> AsyncClose(::grpc::ClientContext* context, const ::carml::org::predictor::Predictor& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::carml::org::predictor::PredictorCloseResponse>>(AsyncCloseRaw(context, request, cq));
    }
    ::grpc::Status URLs(::grpc::ClientContext* context, const ::carml::org::predictor::URLsRequest& request, ::carml::org::predictor::FeaturesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::carml::org::predictor::FeaturesResponse>> AsyncURLs(::grpc::ClientContext* context, const ::carml::org::predictor::URLsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::carml::org::predictor::FeaturesResponse>>(AsyncURLsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::carml::org::predictor::FeatureResponse>> URLsStream(::grpc::ClientContext* context, const ::carml::org::predictor::URLsRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::carml::org::predictor::FeatureResponse>>(URLsStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::carml::org::predictor::FeatureResponse>> AsyncURLsStream(::grpc::ClientContext* context, const ::carml::org::predictor::URLsRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::carml::org::predictor::FeatureResponse>>(AsyncURLsStreamRaw(context, request, cq, tag));
    }
    ::grpc::Status Images(::grpc::ClientContext* context, const ::carml::org::predictor::ImagesRequest& request, ::carml::org::predictor::FeaturesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::carml::org::predictor::FeaturesResponse>> AsyncImages(::grpc::ClientContext* context, const ::carml::org::predictor::ImagesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::carml::org::predictor::FeaturesResponse>>(AsyncImagesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::carml::org::predictor::FeatureResponse>> ImagesStream(::grpc::ClientContext* context, const ::carml::org::predictor::ImagesRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::carml::org::predictor::FeatureResponse>>(ImagesStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::carml::org::predictor::FeatureResponse>> AsyncImagesStream(::grpc::ClientContext* context, const ::carml::org::predictor::ImagesRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::carml::org::predictor::FeatureResponse>>(AsyncImagesStreamRaw(context, request, cq, tag));
    }
    ::grpc::Status Dataset(::grpc::ClientContext* context, const ::carml::org::predictor::DatasetRequest& request, ::carml::org::predictor::FeaturesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::carml::org::predictor::FeaturesResponse>> AsyncDataset(::grpc::ClientContext* context, const ::carml::org::predictor::DatasetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::carml::org::predictor::FeaturesResponse>>(AsyncDatasetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::carml::org::predictor::FeatureResponse>> DatasetStream(::grpc::ClientContext* context, const ::carml::org::predictor::DatasetRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::carml::org::predictor::FeatureResponse>>(DatasetStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::carml::org::predictor::FeatureResponse>> AsyncDatasetStream(::grpc::ClientContext* context, const ::carml::org::predictor::DatasetRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::carml::org::predictor::FeatureResponse>>(AsyncDatasetStreamRaw(context, request, cq, tag));
    }
    ::grpc::Status Reset(::grpc::ClientContext* context, const ::carml::org::predictor::ResetRequest& request, ::carml::org::predictor::ResetResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::carml::org::predictor::ResetResponse>> AsyncReset(::grpc::ClientContext* context, const ::carml::org::predictor::ResetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::carml::org::predictor::ResetResponse>>(AsyncResetRaw(context, request, cq));
    }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    ::grpc::ClientAsyncResponseReader< ::carml::org::predictor::Predictor>* AsyncOpenRaw(::grpc::ClientContext* context, const ::carml::org::predictor::PredictorOpenRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::carml::org::predictor::PredictorCloseResponse>* AsyncCloseRaw(::grpc::ClientContext* context, const ::carml::org::predictor::Predictor& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::carml::org::predictor::FeaturesResponse>* AsyncURLsRaw(::grpc::ClientContext* context, const ::carml::org::predictor::URLsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::carml::org::predictor::FeatureResponse>* URLsStreamRaw(::grpc::ClientContext* context, const ::carml::org::predictor::URLsRequest& request) override;
    ::grpc::ClientAsyncReader< ::carml::org::predictor::FeatureResponse>* AsyncURLsStreamRaw(::grpc::ClientContext* context, const ::carml::org::predictor::URLsRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncResponseReader< ::carml::org::predictor::FeaturesResponse>* AsyncImagesRaw(::grpc::ClientContext* context, const ::carml::org::predictor::ImagesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::carml::org::predictor::FeatureResponse>* ImagesStreamRaw(::grpc::ClientContext* context, const ::carml::org::predictor::ImagesRequest& request) override;
    ::grpc::ClientAsyncReader< ::carml::org::predictor::FeatureResponse>* AsyncImagesStreamRaw(::grpc::ClientContext* context, const ::carml::org::predictor::ImagesRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncResponseReader< ::carml::org::predictor::FeaturesResponse>* AsyncDatasetRaw(::grpc::ClientContext* context, const ::carml::org::predictor::DatasetRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::carml::org::predictor::FeatureResponse>* DatasetStreamRaw(::grpc::ClientContext* context, const ::carml::org::predictor::DatasetRequest& request) override;
    ::grpc::ClientAsyncReader< ::carml::org::predictor::FeatureResponse>* AsyncDatasetStreamRaw(::grpc::ClientContext* context, const ::carml::org::predictor::DatasetRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncResponseReader< ::carml::org::predictor::ResetResponse>* AsyncResetRaw(::grpc::ClientContext* context, const ::carml::org::predictor::ResetRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::RpcMethod rpcmethod_Open_;
    const ::grpc::RpcMethod rpcmethod_Close_;
    const ::grpc::RpcMethod rpcmethod_URLs_;
    const ::grpc::RpcMethod rpcmethod_URLsStream_;
    const ::grpc::RpcMethod rpcmethod_Images_;
    const ::grpc::RpcMethod rpcmethod_ImagesStream_;
    const ::grpc::RpcMethod rpcmethod_Dataset_;
    const ::grpc::RpcMethod rpcmethod_DatasetStream_;
    const ::grpc::RpcMethod rpcmethod_Reset_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Opens a predictor and returns an id where the predictor
    // is accessible. The id can be used to perform inference
    // requests.
    virtual ::grpc::Status Open(::grpc::ServerContext* context, const ::carml::org::predictor::PredictorOpenRequest* request, ::carml::org::predictor::Predictor* response);
    // rpc Information(Predictor) returns (PredictorInformation) {
    //   option (google.api.http) = {
    //     post : "/v1/predict/information",
    //     body : "*"
    //   };
    // }
    //
    // Close a predictor clear it's memory.
    virtual ::grpc::Status Close(::grpc::ServerContext* context, const ::carml::org::predictor::Predictor* request, ::carml::org::predictor::PredictorCloseResponse* response);
    // Image method receives a stream of urls and runs
    // the predictor on all the urls. The
    //
    // The result is a prediction feature stream for each url.
    virtual ::grpc::Status URLs(::grpc::ServerContext* context, const ::carml::org::predictor::URLsRequest* request, ::carml::org::predictor::FeaturesResponse* response);
    // Image method receives a stream of urls and runs
    // the predictor on all the urls. The
    //
    // The result is a prediction feature stream for each url.
    virtual ::grpc::Status URLsStream(::grpc::ServerContext* context, const ::carml::org::predictor::URLsRequest* request, ::grpc::ServerWriter< ::carml::org::predictor::FeatureResponse>* writer);
    // Image method receives a list base64 encoded images and runs
    // the predictor on all the images.
    //
    // The result is a prediction feature list for each image.
    virtual ::grpc::Status Images(::grpc::ServerContext* context, const ::carml::org::predictor::ImagesRequest* request, ::carml::org::predictor::FeaturesResponse* response);
    // Image method receives a list base64 encoded images and runs
    // the predictor on all the images.
    //
    // The result is a prediction feature stream for each image.
    virtual ::grpc::Status ImagesStream(::grpc::ServerContext* context, const ::carml::org::predictor::ImagesRequest* request, ::grpc::ServerWriter< ::carml::org::predictor::FeatureResponse>* writer);
    // Dataset method receives a single dataset and runs
    // the predictor on all elements of the dataset.
    //
    // The result is a prediction feature list.
    virtual ::grpc::Status Dataset(::grpc::ServerContext* context, const ::carml::org::predictor::DatasetRequest* request, ::carml::org::predictor::FeaturesResponse* response);
    // Dataset method receives a single dataset and runs
    // the predictor on all elements of the dataset.
    //
    // The result is a prediction feature stream.
    virtual ::grpc::Status DatasetStream(::grpc::ServerContext* context, const ::carml::org::predictor::DatasetRequest* request, ::grpc::ServerWriter< ::carml::org::predictor::FeatureResponse>* writer);
    // Clear method clears the internal cache of the predictors
    virtual ::grpc::Status Reset(::grpc::ServerContext* context, const ::carml::org::predictor::ResetRequest* request, ::carml::org::predictor::ResetResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Open : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Open() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Open() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Open(::grpc::ServerContext* context, const ::carml::org::predictor::PredictorOpenRequest* request, ::carml::org::predictor::Predictor* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOpen(::grpc::ServerContext* context, ::carml::org::predictor::PredictorOpenRequest* request, ::grpc::ServerAsyncResponseWriter< ::carml::org::predictor::Predictor>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Close : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Close() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_Close() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Close(::grpc::ServerContext* context, const ::carml::org::predictor::Predictor* request, ::carml::org::predictor::PredictorCloseResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestClose(::grpc::ServerContext* context, ::carml::org::predictor::Predictor* request, ::grpc::ServerAsyncResponseWriter< ::carml::org::predictor::PredictorCloseResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_URLs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_URLs() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_URLs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status URLs(::grpc::ServerContext* context, const ::carml::org::predictor::URLsRequest* request, ::carml::org::predictor::FeaturesResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestURLs(::grpc::ServerContext* context, ::carml::org::predictor::URLsRequest* request, ::grpc::ServerAsyncResponseWriter< ::carml::org::predictor::FeaturesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_URLsStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_URLsStream() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_URLsStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status URLsStream(::grpc::ServerContext* context, const ::carml::org::predictor::URLsRequest* request, ::grpc::ServerWriter< ::carml::org::predictor::FeatureResponse>* writer) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestURLsStream(::grpc::ServerContext* context, ::carml::org::predictor::URLsRequest* request, ::grpc::ServerAsyncWriter< ::carml::org::predictor::FeatureResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(3, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Images : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Images() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_Images() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Images(::grpc::ServerContext* context, const ::carml::org::predictor::ImagesRequest* request, ::carml::org::predictor::FeaturesResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImages(::grpc::ServerContext* context, ::carml::org::predictor::ImagesRequest* request, ::grpc::ServerAsyncResponseWriter< ::carml::org::predictor::FeaturesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ImagesStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ImagesStream() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_ImagesStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImagesStream(::grpc::ServerContext* context, const ::carml::org::predictor::ImagesRequest* request, ::grpc::ServerWriter< ::carml::org::predictor::FeatureResponse>* writer) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImagesStream(::grpc::ServerContext* context, ::carml::org::predictor::ImagesRequest* request, ::grpc::ServerAsyncWriter< ::carml::org::predictor::FeatureResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(5, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Dataset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Dataset() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_Dataset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Dataset(::grpc::ServerContext* context, const ::carml::org::predictor::DatasetRequest* request, ::carml::org::predictor::FeaturesResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDataset(::grpc::ServerContext* context, ::carml::org::predictor::DatasetRequest* request, ::grpc::ServerAsyncResponseWriter< ::carml::org::predictor::FeaturesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DatasetStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_DatasetStream() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_DatasetStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DatasetStream(::grpc::ServerContext* context, const ::carml::org::predictor::DatasetRequest* request, ::grpc::ServerWriter< ::carml::org::predictor::FeatureResponse>* writer) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDatasetStream(::grpc::ServerContext* context, ::carml::org::predictor::DatasetRequest* request, ::grpc::ServerAsyncWriter< ::carml::org::predictor::FeatureResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(7, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Reset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Reset() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_Reset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Reset(::grpc::ServerContext* context, const ::carml::org::predictor::ResetRequest* request, ::carml::org::predictor::ResetResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReset(::grpc::ServerContext* context, ::carml::org::predictor::ResetRequest* request, ::grpc::ServerAsyncResponseWriter< ::carml::org::predictor::ResetResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Open<WithAsyncMethod_Close<WithAsyncMethod_URLs<WithAsyncMethod_URLsStream<WithAsyncMethod_Images<WithAsyncMethod_ImagesStream<WithAsyncMethod_Dataset<WithAsyncMethod_DatasetStream<WithAsyncMethod_Reset<Service > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithGenericMethod_Open : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Open() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Open() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Open(::grpc::ServerContext* context, const ::carml::org::predictor::PredictorOpenRequest* request, ::carml::org::predictor::Predictor* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Close : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Close() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_Close() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Close(::grpc::ServerContext* context, const ::carml::org::predictor::Predictor* request, ::carml::org::predictor::PredictorCloseResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_URLs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_URLs() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_URLs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status URLs(::grpc::ServerContext* context, const ::carml::org::predictor::URLsRequest* request, ::carml::org::predictor::FeaturesResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_URLsStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_URLsStream() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_URLsStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status URLsStream(::grpc::ServerContext* context, const ::carml::org::predictor::URLsRequest* request, ::grpc::ServerWriter< ::carml::org::predictor::FeatureResponse>* writer) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Images : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Images() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_Images() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Images(::grpc::ServerContext* context, const ::carml::org::predictor::ImagesRequest* request, ::carml::org::predictor::FeaturesResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ImagesStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ImagesStream() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_ImagesStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImagesStream(::grpc::ServerContext* context, const ::carml::org::predictor::ImagesRequest* request, ::grpc::ServerWriter< ::carml::org::predictor::FeatureResponse>* writer) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Dataset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Dataset() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_Dataset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Dataset(::grpc::ServerContext* context, const ::carml::org::predictor::DatasetRequest* request, ::carml::org::predictor::FeaturesResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DatasetStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_DatasetStream() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_DatasetStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DatasetStream(::grpc::ServerContext* context, const ::carml::org::predictor::DatasetRequest* request, ::grpc::ServerWriter< ::carml::org::predictor::FeatureResponse>* writer) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Reset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Reset() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_Reset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Reset(::grpc::ServerContext* context, const ::carml::org::predictor::ResetRequest* request, ::carml::org::predictor::ResetResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Open : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Open() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::StreamedUnaryHandler< ::carml::org::predictor::PredictorOpenRequest, ::carml::org::predictor::Predictor>(std::bind(&WithStreamedUnaryMethod_Open<BaseClass>::StreamedOpen, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Open() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Open(::grpc::ServerContext* context, const ::carml::org::predictor::PredictorOpenRequest* request, ::carml::org::predictor::Predictor* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedOpen(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::carml::org::predictor::PredictorOpenRequest,::carml::org::predictor::Predictor>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Close : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Close() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::StreamedUnaryHandler< ::carml::org::predictor::Predictor, ::carml::org::predictor::PredictorCloseResponse>(std::bind(&WithStreamedUnaryMethod_Close<BaseClass>::StreamedClose, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Close() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Close(::grpc::ServerContext* context, const ::carml::org::predictor::Predictor* request, ::carml::org::predictor::PredictorCloseResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedClose(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::carml::org::predictor::Predictor,::carml::org::predictor::PredictorCloseResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_URLs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_URLs() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::StreamedUnaryHandler< ::carml::org::predictor::URLsRequest, ::carml::org::predictor::FeaturesResponse>(std::bind(&WithStreamedUnaryMethod_URLs<BaseClass>::StreamedURLs, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_URLs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status URLs(::grpc::ServerContext* context, const ::carml::org::predictor::URLsRequest* request, ::carml::org::predictor::FeaturesResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedURLs(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::carml::org::predictor::URLsRequest,::carml::org::predictor::FeaturesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Images : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Images() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::StreamedUnaryHandler< ::carml::org::predictor::ImagesRequest, ::carml::org::predictor::FeaturesResponse>(std::bind(&WithStreamedUnaryMethod_Images<BaseClass>::StreamedImages, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Images() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Images(::grpc::ServerContext* context, const ::carml::org::predictor::ImagesRequest* request, ::carml::org::predictor::FeaturesResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedImages(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::carml::org::predictor::ImagesRequest,::carml::org::predictor::FeaturesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Dataset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Dataset() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::StreamedUnaryHandler< ::carml::org::predictor::DatasetRequest, ::carml::org::predictor::FeaturesResponse>(std::bind(&WithStreamedUnaryMethod_Dataset<BaseClass>::StreamedDataset, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Dataset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Dataset(::grpc::ServerContext* context, const ::carml::org::predictor::DatasetRequest* request, ::carml::org::predictor::FeaturesResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDataset(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::carml::org::predictor::DatasetRequest,::carml::org::predictor::FeaturesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Reset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Reset() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::StreamedUnaryHandler< ::carml::org::predictor::ResetRequest, ::carml::org::predictor::ResetResponse>(std::bind(&WithStreamedUnaryMethod_Reset<BaseClass>::StreamedReset, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Reset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Reset(::grpc::ServerContext* context, const ::carml::org::predictor::ResetRequest* request, ::carml::org::predictor::ResetResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedReset(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::carml::org::predictor::ResetRequest,::carml::org::predictor::ResetResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Open<WithStreamedUnaryMethod_Close<WithStreamedUnaryMethod_URLs<WithStreamedUnaryMethod_Images<WithStreamedUnaryMethod_Dataset<WithStreamedUnaryMethod_Reset<Service > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_URLsStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithSplitStreamingMethod_URLsStream() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::SplitServerStreamingHandler< ::carml::org::predictor::URLsRequest, ::carml::org::predictor::FeatureResponse>(std::bind(&WithSplitStreamingMethod_URLsStream<BaseClass>::StreamedURLsStream, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_URLsStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status URLsStream(::grpc::ServerContext* context, const ::carml::org::predictor::URLsRequest* request, ::grpc::ServerWriter< ::carml::org::predictor::FeatureResponse>* writer) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedURLsStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::carml::org::predictor::URLsRequest,::carml::org::predictor::FeatureResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_ImagesStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithSplitStreamingMethod_ImagesStream() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::SplitServerStreamingHandler< ::carml::org::predictor::ImagesRequest, ::carml::org::predictor::FeatureResponse>(std::bind(&WithSplitStreamingMethod_ImagesStream<BaseClass>::StreamedImagesStream, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_ImagesStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ImagesStream(::grpc::ServerContext* context, const ::carml::org::predictor::ImagesRequest* request, ::grpc::ServerWriter< ::carml::org::predictor::FeatureResponse>* writer) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedImagesStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::carml::org::predictor::ImagesRequest,::carml::org::predictor::FeatureResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_DatasetStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithSplitStreamingMethod_DatasetStream() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::SplitServerStreamingHandler< ::carml::org::predictor::DatasetRequest, ::carml::org::predictor::FeatureResponse>(std::bind(&WithSplitStreamingMethod_DatasetStream<BaseClass>::StreamedDatasetStream, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_DatasetStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DatasetStream(::grpc::ServerContext* context, const ::carml::org::predictor::DatasetRequest* request, ::grpc::ServerWriter< ::carml::org::predictor::FeatureResponse>* writer) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedDatasetStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::carml::org::predictor::DatasetRequest,::carml::org::predictor::FeatureResponse>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_URLsStream<WithSplitStreamingMethod_ImagesStream<WithSplitStreamingMethod_DatasetStream<Service > > > SplitStreamedService;
  typedef WithStreamedUnaryMethod_Open<WithStreamedUnaryMethod_Close<WithStreamedUnaryMethod_URLs<WithSplitStreamingMethod_URLsStream<WithStreamedUnaryMethod_Images<WithSplitStreamingMethod_ImagesStream<WithStreamedUnaryMethod_Dataset<WithSplitStreamingMethod_DatasetStream<WithStreamedUnaryMethod_Reset<Service > > > > > > > > > StreamedService;
};

}  // namespace predictor
}  // namespace org
}  // namespace carml


#endif  // GRPC_predictor_2eproto__INCLUDED
